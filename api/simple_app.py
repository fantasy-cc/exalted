"""
Simplified FastAPI Backend for PoE2 Currency Arbitrage Calculator

This version reads from static JSON files generated by GitHub Actions,
making it compatible with Vercel serverless functions.
"""

from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from typing import Dict, List
import logging

from static_data import (
    load_currencies,
    load_rates,
    get_exchange_rate,
    convert_currency,
    find_arbitrage_opportunities
)

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create FastAPI application
app = FastAPI(
    title="PoE2 Currency Arbitrage API",
    description="Backend API for Path of Exile 2 currency arbitrage calculations (static data mode)",
    version="2.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "name": "PoE2 Currency Arbitrage API (Static Data)",
        "version": "2.0.0",
        "description": "Reads from GitHub Actions-generated JSON files",
        "data_source": "GitHub Actions + POE2Scout.com (every 5 minutes)",
        "endpoints": {
            "currencies": "/api/currencies",
            "rates": "/api/rates/{league}",
            "arbitrage": "/api/arbitrage/{league}",
            "health": "/api/health"
        }
    }


@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    try:
        currencies_data = load_currencies()
        rates_data = load_rates()
        
        return {
            "status": "healthy",
            "currencies_count": len(currencies_data.get('currencies', [])),
            "rates_count": rates_data['metadata'].get('total_pairs', 0),
            "data_source": currencies_data.get('source', 'unknown'),
            "last_update": currencies_data.get('fetched_at', 'unknown')
        }
    except Exception as e:
        return {
            "status": "degraded",
            "error": str(e)
        }


@app.get("/api/currencies")
async def get_currencies(
    league: str = Query("Rise of the Abyssal", description="POE2 league name"),
    top_percentage: float = Query(0.8, ge=0.1, le=1.0, description="Percentage of top currencies (ignored in static mode)"),
    force_refresh: bool = Query(False, description="Force refresh (ignored in static mode)")
):
    """
    Get list of supported currencies
    
    Returns currencies from static data file populated by GitHub Actions
    """
    try:
        data = load_currencies()
        
        return {
            "currencies": data.get('currencies', []),
            "total": data.get('total', 0),
            "source": data.get('source', 'github-actions'),
            "league": league,
            "top_percentage": 1.0,  # Static mode includes all scraped currencies
            "fetched_at": data.get('fetched_at', 'unknown')
        }
        
    except Exception as e:
        logger.error(f"Error loading currencies: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to load currency data: {str(e)}"
        )


@app.get("/api/rates/{league}")
async def get_rates(
    league: str,
    top_percentage: float = Query(0.8, description="Percentage of top currencies (ignored in static mode)")
):
    """
    Get current exchange rates
    
    Returns rates from static data file populated by GitHub Actions
    """
    try:
        data = load_rates()
        
        return {
            "rates": data.get('rates', {}),
            "metadata": {
                **data.get('metadata', {}),
                "league": league
            }
        }
        
    except Exception as e:
        logger.error(f"Error loading rates: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to load rate data: {str(e)}"
        )


@app.get("/api/arbitrage/{league}")
async def get_arbitrage_opportunities(
    league: str,
    starting_currency: str = Query("chaos", description="Starting currency for arbitrage"),
    amount: float = Query(100.0, gt=0, description="Starting amount"),
    min_profit: float = Query(0.01, ge=0, description="Minimum profit percentage (0.01 = 1%)"),
    max_results: int = Query(10, gt=0, le=50, description="Maximum results to return"),
    slippage: float = Query(0.0, ge=0, le=0.1, description="Slippage per step (currently ignored)"),
    top_percentage: float = Query(0.8, description="Percentage of currencies (ignored in static mode)")
):
    """
    Find arbitrage opportunities for a specific currency and amount
    
    Returns list of profitable 3-step arbitrage paths
    """
    try:
        # Validate starting currency
        currencies_data = load_currencies()
        valid_currencies = [c['id'] for c in currencies_data.get('currencies', [])]
        
        if starting_currency not in valid_currencies:
            raise HTTPException(
                status_code=400,
                detail=f"Unsupported currency: {starting_currency}. Supported: {', '.join(valid_currencies)}"
            )
        
        # Find opportunities
        opportunities = find_arbitrage_opportunities(
            starting_currency=starting_currency,
            amount=amount,
            min_profit=min_profit
        )
        
        # Limit results
        opportunities = opportunities[:max_results]
        
        # Calculate summary stats
        if opportunities:
            best_profit = max(op['profit_percentage'] for op in opportunities)
            avg_profit = sum(op['profit_percentage'] for op in opportunities) / len(opportunities)
        else:
            best_profit = 0
            avg_profit = 0
        
        rates_data = load_rates()
        
        return {
            "opportunities": opportunities,
            "total_found": len(opportunities),
            "starting_currency": starting_currency,
            "league": league,
            "summary": {
                "best_profit_percentage": round(best_profit, 2),
                "average_profit_percentage": round(avg_profit, 2),
                "total_opportunities": len(opportunities)
            },
            "data_source": {
                "source": rates_data['metadata'].get('source', 'unknown'),
                "fetched_at": rates_data['metadata'].get('fetched_at', 'unknown'),
                "league": league
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error finding arbitrage opportunities: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to find arbitrage opportunities: {str(e)}"
        )


@app.post("/api/refresh/{league}")
async def refresh_data(league: str):
    """
    Refresh data endpoint (no-op in static mode)
    
    Data is automatically refreshed by GitHub Actions every 5 minutes
    """
    currencies_data = load_currencies()
    
    return {
        "message": "Data is automatically refreshed by GitHub Actions every 5 minutes",
        "current_data_source": currencies_data.get('source', 'unknown'),
        "last_update": currencies_data.get('fetched_at', 'unknown'),
        "league": league,
        "note": "To manually update, trigger the GitHub Actions workflow"
    }


# For local testing
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

